/**
 * Data Integrity Service
 *
 * Provides comprehensive data integrity checking, orphaned data detection,
 * and automatic repair mechanisms for conversation storage.
 *
 * Requirements: 3.3, 5.1, 5.2, 5.3, 5.4, 5.5
 */

import type { Conversation } from '../types/index.js';
import type { ConversationStorage } from './storage.js';
import { frontendLogger } from '../utils/logger.js';
import { PersistenceError, PersistenceErrorType } from '../errors/persistence-error.js';

/**
 * Integrity report generated by startup check
 *
 * Requirement 5.5: Generate IntegrityReport with recommendations
 */
export interface IntegrityReport {
  /**
   * Total number of conversations checked
   */
  totalConversations: number;

  /**
   * Number of valid conversations
   */
  validConversations: number;

  /**
   * Number of orphaned messages found
   */
  orphanedMessages: number;

  /**
   * Number of corrupted conversations found
   */
  corruptedConversations: number;

  /**
   * Number of missing references found
   */
  missingReferences: number;

  /**
   * List of conversation IDs with issues
   */
  conversationsWithIssues: string[];

  /**
   * Recommendations for fixing issues
   */
  recommendations: string[];

  /**
   * Timestamp when check was performed
   */
  timestamp: Date;

  /**
   * Duration of integrity check in milliseconds
   */
  duration: number;

  /**
   * Whether any issues were found
   */
  hasIssues: boolean;
}

/**
 * Cleanup result with detailed statistics
 *
 * Requirement 3.3: Return cleanup statistics
 */
export interface CleanupResult {
  /**
   * Number of orphaned messages removed
   */
  messagesRemoved: number;

  /**
   * Number of bytes freed
   */
  bytesFreed: number;

  /**
   * Whether cleanup was successful
   */
  success: boolean;

  /**
   * Error message if cleanup failed
   */
  error?: string;

  /**
   * Correlation ID for debugging
   */
  correlationId: string;

  /**
   * Timestamp when cleanup was performed
   */
  timestamp: Date;
}



/**
 * Relationship verification result
 */
interface RelationshipReport {
  /**
   * Number of valid conversation-message relationships
   */
  validRelationships: number;

  /**
   * Number of broken relationships
   */
  brokenRelationships: number;

  /**
   * List of conversation IDs with broken relationships
   */
  conversationsWithBrokenRelationships: string[];
}

/**
 * Schema validation result
 */
interface ValidationResult {
  /**
   * Whether validation passed
   */
  valid: boolean;

  /**
   * List of validation errors
   */
  errors: string[];

  /**
   * Number of conversations validated
   */
  conversationsValidated: number;

  /**
   * Number of conversations with schema errors
   */
  conversationsWithErrors: number;
}

/**
 * Repair result
 */
interface RepairResult {
  /**
   * Number of conversations repaired
   */
  conversationsRepaired: number;

  /**
   * Number of conversations that couldn't be repaired
   */
  conversationsFailed: number;

  /**
   * Whether repair was successful
   */
  success: boolean;

  /**
   * Error message if repair failed
   */
  error?: string;
}

/**
 * Data Integrity Service
 *
 * Provides comprehensive data integrity checking and repair mechanisms
 * for conversation storage. Detects orphaned data, validates schemas,
 * and performs automatic repairs.
 *
 * Requirements:
 * - 3.3: Detect and clean up orphaned data
 * - 5.1: Run integrity checks on startup
 * - 5.2: Detect orphaned messages
 * - 5.3: Clean up orphaned messages
 * - 5.4: Check for corrupted conversations
 * - 5.5: Generate IntegrityReport with recommendations
 */
export class DataIntegrityService {
  private readonly storage: ConversationStorage;
  private readonly correlationId: string;

  /**
   * Create a new DataIntegrityService
   *
   * @param storage - ConversationStorage instance to check
   *
   * Requirement 3.3, 5.1: Initialize service with ConversationStorage reference
   */
  constructor(storage: ConversationStorage) {
    this.storage = storage;
    this.correlationId = crypto.randomUUID();

    frontendLogger.info('DataIntegrityService initialized', {
      metadata: {
        correlationId: this.correlationId,
      },
    });
  }

  /**
   * Run comprehensive integrity check on application initialization
   *
   * Checks for:
   * - Orphaned messages (messages without parent conversation)
   * - Corrupted conversations (invalid schema)
   * - Missing references (broken relationships)
   * - Data consistency issues
   *
   * @returns IntegrityReport with findings and recommendations
   *
   * Requirements:
   * - 3.3: Check for orphaned messages
   * - 5.4: Check for corrupted conversations (invalid schema)
   * - 5.5: Generate IntegrityReport with recommendations
   */
  public async runStartupCheck(): Promise<IntegrityReport> {
    const startTime = Date.now();
    const correlationId = crypto.randomUUID();

    frontendLogger.info('Starting integrity check', {
      metadata: { correlationId },
    });

    try {
      // Get all conversations
      const conversations = await this.storage.getAllConversations();
      const totalConversations = conversations.length;

      // Check for orphaned messages
      const orphanedMessageIds = await this.detectOrphanedMessages();

      // Validate conversation schemas
      const validationResult = await this.validateSchema();

      // Verify relationships
      const relationshipReport = await this.verifyRelationships();

      // Calculate valid conversations
      const validConversations =
        totalConversations - validationResult.conversationsWithErrors;

      // Identify conversations with issues
      const conversationsWithIssues = new Set<string>();

      // Add conversations with schema errors
      validationResult.errors.forEach((error) => {
        const match = error.match(/Conversation ([a-f0-9-]+)/);
        if (match?.[1]) {
          conversationsWithIssues.add(match[1]);
        }
      });

      // Add conversations with broken relationships
      relationshipReport.conversationsWithBrokenRelationships.forEach((id) => {
        conversationsWithIssues.add(id);
      });

      // Generate recommendations
      const recommendations: string[] = [];

      if (orphanedMessageIds.length > 0) {
        recommendations.push(
          `Found ${orphanedMessageIds.length} orphaned messages. Run cleanup to remove them.`
        );
      }

      if (validationResult.conversationsWithErrors > 0) {
        recommendations.push(
          `Found ${validationResult.conversationsWithErrors} corrupted conversations. Run repair to fix them.`
        );
      }

      if (relationshipReport.brokenRelationships > 0) {
        recommendations.push(
          `Found ${relationshipReport.brokenRelationships} broken relationships. Run repair to fix them.`
        );
      }

      if (recommendations.length === 0) {
        recommendations.push('No issues found. Data integrity is good.');
      }

      const duration = Date.now() - startTime;
      const hasIssues =
        orphanedMessageIds.length > 0 ||
        validationResult.conversationsWithErrors > 0 ||
        relationshipReport.brokenRelationships > 0;

      const report: IntegrityReport = {
        totalConversations,
        validConversations,
        orphanedMessages: orphanedMessageIds.length,
        corruptedConversations: validationResult.conversationsWithErrors,
        missingReferences: relationshipReport.brokenRelationships,
        conversationsWithIssues: Array.from(conversationsWithIssues),
        recommendations,
        timestamp: new Date(),
        duration,
        hasIssues,
      };

      frontendLogger.info('Integrity check completed', {
        metadata: {
          correlationId,
          duration,
          hasIssues,
          orphanedMessages: orphanedMessageIds.length,
          corruptedConversations: validationResult.conversationsWithErrors,
          missingReferences: relationshipReport.brokenRelationships,
        },
      });

      return report;
    } catch (error) {
      const duration = Date.now() - startTime;

      frontendLogger.error('Integrity check failed', {
        error: error instanceof Error ? error : new Error(String(error)),
        metadata: { correlationId, duration },
      });

      // Return report with error
      return {
        totalConversations: 0,
        validConversations: 0,
        orphanedMessages: 0,
        corruptedConversations: 0,
        missingReferences: 0,
        conversationsWithIssues: [],
        recommendations: [
          'Integrity check failed. Please try again or contact support.',
        ],
        timestamp: new Date(),
        duration,
        hasIssues: true,
      };
    }
  }

  /**
   * Detect orphaned messages (messages without parent conversation)
   *
   * Searches both IndexedDB and localStorage for messages that don't have
   * a corresponding conversation.
   *
   * @returns Array of orphaned message IDs with metadata
   *
   * Requirements:
   * - 3.3: Find messages without parent conversation in IndexedDB
   * - 3.3: Find messages without parent conversation in localStorage
   */
  public async detectOrphanedMessages(): Promise<string[]> {
    const correlationId = crypto.randomUUID();

    frontendLogger.info('Detecting orphaned messages', {
      metadata: { correlationId },
    });

    try {
      // Get all conversations
      const conversations = await this.storage.getAllConversations();
      const conversationIds = new Set(conversations.map((c) => c.id));

      // Get all message IDs from conversations
      const validMessageIds = new Set<string>();
      conversations.forEach((conversation) => {
        conversation.messages.forEach((message) => {
          validMessageIds.add(message.id);
        });
      });

      // Check IndexedDB for orphaned messages
      const orphanedIds = await this.detectOrphanedMessagesIndexedDB(
        conversationIds,
        validMessageIds
      );

      // Check localStorage for orphaned messages
      const localStorageOrphanedIds =
        await this.detectOrphanedMessagesLocalStorage(
          conversationIds,
          validMessageIds
        );

      // Combine results
      const allOrphanedIds = new Set([
        ...orphanedIds,
        ...localStorageOrphanedIds,
      ]);

      frontendLogger.info('Orphaned message detection completed', {
        metadata: {
          correlationId,
          orphanedCount: allOrphanedIds.size,
          indexedDBOrphans: orphanedIds.length,
          localStorageOrphans: localStorageOrphanedIds.length,
        },
      });

      return Array.from(allOrphanedIds);
    } catch (error) {
      frontendLogger.error('Failed to detect orphaned messages', {
        error: error instanceof Error ? error : new Error(String(error)),
        metadata: { correlationId },
      });

      throw new PersistenceError(
        PersistenceErrorType.CORRUPTED_DATA,
        'detectOrphanedMessages',
        'Failed to detect orphaned messages',
        {
          correlationId,
          retryable: false,
          originalError: error instanceof Error ? error : new Error(String(error)),
        }
      );
    }
  }

  /**
   * Detect orphaned messages in IndexedDB
   */
  private async detectOrphanedMessagesIndexedDB(
    _conversationIds: Set<string>,
    _validMessageIds: Set<string>
  ): Promise<string[]> {
    // This method would need access to the IndexedDB database
    // For now, we'll return an empty array as the storage service
    // doesn't expose direct access to the messages store
    // In a real implementation, this would query the messages store directly

    // TODO: Implement direct IndexedDB access for orphaned message detection
    // This requires exposing the database connection from ConversationStorage
    // or implementing a method in ConversationStorage to query messages directly

    return [];
  }

  /**
   * Detect orphaned messages in localStorage
   */
  private async detectOrphanedMessagesLocalStorage(
    conversationIds: Set<string>,
    validMessageIds: Set<string>
  ): Promise<string[]> {
    const orphanedIds: string[] = [];

    try {
      // Check localStorage for message keys
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key?.startsWith('message_')) {
          const messageId = key.replace('message_', '');

          // Check if message ID is valid
          if (!validMessageIds.has(messageId)) {
            orphanedIds.push(messageId);
          }
        }
      }
    } catch (error) {
      frontendLogger.warn('Failed to check localStorage for orphaned messages', {
        error: error instanceof Error ? error : new Error(String(error)),
      });
    }

    return orphanedIds;
  }

  /**
   * Clean up orphaned messages
   *
   * Deletes orphaned messages from both IndexedDB and localStorage,
   * returning detailed cleanup statistics.
   *
   * @param messageIds - Optional array of specific message IDs to clean up.
   *                     If not provided, detects and cleans all orphaned messages.
   * @returns CleanupResult with statistics
   *
   * Requirements:
   * - 3.3: Delete orphaned messages from both storage backends
   * - 3.3: Return cleanup statistics (messagesRemoved, bytesFreed)
   * - 3.3: Log cleanup operations with correlation IDs
   */
  public async cleanupOrphanedMessages(
    messageIds?: string[]
  ): Promise<CleanupResult> {
    const correlationId = crypto.randomUUID();
    const startTime = Date.now();

    frontendLogger.info('Starting orphaned message cleanup', {
      metadata: {
        correlationId,
        messageCount: messageIds?.length ?? 'auto-detect',
      },
    });

    try {
      // Detect orphaned messages if not provided
      const idsToClean = messageIds ?? (await this.detectOrphanedMessages());

      if (idsToClean.length === 0) {
        frontendLogger.info('No orphaned messages to clean up', {
          metadata: { correlationId },
        });

        return {
          messagesRemoved: 0,
          bytesFreed: 0,
          success: true,
          correlationId,
          timestamp: new Date(),
        };
      }

      let messagesRemoved = 0;
      let bytesFreed = 0;

      // Clean up from localStorage
      for (const messageId of idsToClean) {
        try {
          const key = `message_${messageId}`;
          const value = localStorage.getItem(key);

          if (value !== null) {
            // Estimate bytes freed (UTF-16 encoding, 2 bytes per character)
            bytesFreed += value.length * 2;
            localStorage.removeItem(key);
            messagesRemoved++;
          }
        } catch (error) {
          frontendLogger.warn('Failed to remove orphaned message from localStorage', {
            error: error instanceof Error ? error : new Error(String(error)),
            metadata: { messageId, correlationId },
          });
        }
      }

      // TODO: Clean up from IndexedDB
      // This requires direct access to the messages store
      // For now, we only clean up from localStorage

      const duration = Date.now() - startTime;

      frontendLogger.info('Orphaned message cleanup completed', {
        metadata: {
          correlationId,
          messagesRemoved,
          bytesFreed,
          duration,
        },
      });

      return {
        messagesRemoved,
        bytesFreed,
        success: true,
        correlationId,
        timestamp: new Date(),
      };
    } catch (error) {
      frontendLogger.error('Orphaned message cleanup failed', {
        error: error instanceof Error ? error : new Error(String(error)),
        metadata: { correlationId },
      });

      return {
        messagesRemoved: 0,
        bytesFreed: 0,
        success: false,
        error:
          error instanceof Error ? error.message : 'Unknown error occurred',
        correlationId,
        timestamp: new Date(),
      };
    }
  }

  /**
   * Verify conversation-message relationships
   *
   * Checks that all messages reference valid conversations and that
   * all conversation message references are valid.
   *
   * @returns RelationshipReport with verification results
   */
  private async verifyRelationships(): Promise<RelationshipReport> {
    const correlationId = crypto.randomUUID();

    frontendLogger.info('Verifying conversation-message relationships', {
      metadata: { correlationId },
    });

    try {
      const conversations = await this.storage.getAllConversations();
      let validRelationships = 0;
      let brokenRelationships = 0;
      const conversationsWithBrokenRelationships: string[] = [];

      for (const conversation of conversations) {
        let hasBrokenRelationship = false;

        // Check each message in the conversation
        for (const message of conversation.messages) {
          // Verify message has required fields
          if (!message.id || !message.content || !message.role) {
            brokenRelationships++;
            hasBrokenRelationship = true;
          } else {
            validRelationships++;
          }
        }

        if (hasBrokenRelationship) {
          conversationsWithBrokenRelationships.push(conversation.id);
        }
      }

      frontendLogger.info('Relationship verification completed', {
        metadata: {
          correlationId,
          validRelationships,
          brokenRelationships,
          conversationsWithIssues: conversationsWithBrokenRelationships.length,
        },
      });

      return {
        validRelationships,
        brokenRelationships,
        conversationsWithBrokenRelationships,
      };
    } catch (error) {
      frontendLogger.error('Relationship verification failed', {
        error: error instanceof Error ? error : new Error(String(error)),
        metadata: { correlationId },
      });

      return {
        validRelationships: 0,
        brokenRelationships: 0,
        conversationsWithBrokenRelationships: [],
      };
    }
  }

  /**
   * Validate conversation data schema
   *
   * Checks that all conversations conform to the expected schema
   * and have valid data types for all fields.
   *
   * @returns ValidationResult with validation errors
   *
   * Requirement 5.4: Check for corrupted conversations (invalid schema)
   */
  private async validateSchema(): Promise<ValidationResult> {
    const correlationId = crypto.randomUUID();

    frontendLogger.info('Validating conversation schemas', {
      metadata: { correlationId },
    });

    try {
      const conversations = await this.storage.getAllConversations();
      const errors: string[] = [];
      let conversationsWithErrors = 0;

      for (const conversation of conversations) {
        const conversationErrors = this.validateConversationSchema(conversation);

        if (conversationErrors.length > 0) {
          conversationsWithErrors++;
          errors.push(...conversationErrors);
        }
      }

      frontendLogger.info('Schema validation completed', {
        metadata: {
          correlationId,
          conversationsValidated: conversations.length,
          conversationsWithErrors,
          totalErrors: errors.length,
        },
      });

      return {
        valid: errors.length === 0,
        errors,
        conversationsValidated: conversations.length,
        conversationsWithErrors,
      };
    } catch (error) {
      frontendLogger.error('Schema validation failed', {
        error: error instanceof Error ? error : new Error(String(error)),
        metadata: { correlationId },
      });

      return {
        valid: false,
        errors: ['Schema validation failed'],
        conversationsValidated: 0,
        conversationsWithErrors: 0,
      };
    }
  }

  /**
   * Validate a single conversation schema
   */
  private validateConversationSchema(conversation: Conversation): string[] {
    const errors: string[] = [];

    // Validate required fields
    if (!conversation.id || typeof conversation.id !== 'string') {
      errors.push(`Conversation ${conversation.id ?? 'unknown'}: Invalid or missing ID`);
    }

    if (!conversation.title || typeof conversation.title !== 'string') {
      errors.push(`Conversation ${conversation.id}: Invalid or missing title`);
    }

    if (!conversation.sessionId || typeof conversation.sessionId !== 'string') {
      errors.push(`Conversation ${conversation.id}: Invalid or missing sessionId`);
    }

    if (!conversation.selectedModel || typeof conversation.selectedModel !== 'string') {
      errors.push(`Conversation ${conversation.id}: Invalid or missing selectedModel`);
    }

    // Validate dates
    if (!(conversation.createdAt instanceof Date) || isNaN(conversation.createdAt.getTime())) {
      errors.push(`Conversation ${conversation.id}: Invalid createdAt date`);
    }

    if (!(conversation.updatedAt instanceof Date) || isNaN(conversation.updatedAt.getTime())) {
      errors.push(`Conversation ${conversation.id}: Invalid updatedAt date`);
    }

    // Validate messages array
    if (!Array.isArray(conversation.messages)) {
      errors.push(`Conversation ${conversation.id}: Messages must be an array`);
    } else {
      // Validate each message
      conversation.messages.forEach((message, index) => {
        if (!message.id || typeof message.id !== 'string') {
          errors.push(`Conversation ${conversation.id}, Message ${index}: Invalid or missing ID`);
        }

        if (!message.content || typeof message.content !== 'string') {
          errors.push(`Conversation ${conversation.id}, Message ${index}: Invalid or missing content`);
        }

        if (!message.role || (message.role !== 'user' && message.role !== 'assistant')) {
          errors.push(`Conversation ${conversation.id}, Message ${index}: Invalid role`);
        }

        if (!(message.timestamp instanceof Date) || isNaN(message.timestamp.getTime())) {
          errors.push(`Conversation ${conversation.id}, Message ${index}: Invalid timestamp`);
        }
      });
    }

    // Validate boolean fields
    if (typeof conversation.isStreaming !== 'boolean') {
      errors.push(`Conversation ${conversation.id}: isStreaming must be a boolean`);
    }

    // Validate arrays
    if (!Array.isArray(conversation.modelHistory)) {
      errors.push(`Conversation ${conversation.id}: modelHistory must be an array`);
    }

    if (!Array.isArray(conversation.compressionHistory)) {
      errors.push(`Conversation ${conversation.id}: compressionHistory must be an array`);
    }

    return errors;
  }

  /**
   * Repair corrupted conversations
   *
   * Attempts to repair conversations with schema errors or broken relationships.
   * This may involve:
   * - Fixing invalid dates
   * - Removing invalid messages
   * - Restoring missing required fields with defaults
   *
   * @returns RepairResult with repair statistics
   */
  public async repairCorruptedConversations(): Promise<RepairResult> {
    const correlationId = crypto.randomUUID();

    frontendLogger.info('Starting conversation repair', {
      metadata: { correlationId },
    });

    try {
      const conversations = await this.storage.getAllConversations();
      let conversationsRepaired = 0;
      let conversationsFailed = 0;

      for (const conversation of conversations) {
        const errors = this.validateConversationSchema(conversation);

        if (errors.length > 0) {
          try {
            // Attempt to repair the conversation
            const repaired = this.repairConversation(conversation);

            // Validate repaired conversation
            const repairedErrors = this.validateConversationSchema(repaired);

            if (repairedErrors.length === 0) {
              // Save repaired conversation
              await this.storage.storeConversation(repaired);
              conversationsRepaired++;

              frontendLogger.info('Conversation repaired', {
                metadata: {
                  correlationId,
                  conversationId: conversation.id,
                  errorsFixed: errors.length,
                },
              });
            } else {
              conversationsFailed++;

              frontendLogger.warn('Failed to repair conversation', {
                metadata: {
                  correlationId,
                  conversationId: conversation.id,
                  remainingErrors: repairedErrors.length,
                },
              });
            }
          } catch (error) {
            conversationsFailed++;

            frontendLogger.error('Conversation repair failed', {
              error: error instanceof Error ? error : new Error(String(error)),
              metadata: {
                correlationId,
                conversationId: conversation.id,
              },
            });
          }
        }
      }

      frontendLogger.info('Conversation repair completed', {
        metadata: {
          correlationId,
          conversationsRepaired,
          conversationsFailed,
        },
      });

      return {
        conversationsRepaired,
        conversationsFailed,
        success: conversationsFailed === 0,
      };
    } catch (error) {
      frontendLogger.error('Conversation repair failed', {
        error: error instanceof Error ? error : new Error(String(error)),
        metadata: { correlationId },
      });

      return {
        conversationsRepaired: 0,
        conversationsFailed: 0,
        success: false,
        error:
          error instanceof Error ? error.message : 'Unknown error occurred',
      };
    }
  }

  /**
   * Repair a single conversation
   */
  private repairConversation(conversation: Conversation): Conversation {
    const repaired = { ...conversation };

    // Fix invalid dates
    if (!(repaired.createdAt instanceof Date) || isNaN(repaired.createdAt.getTime())) {
      repaired.createdAt = new Date();
    }

    if (!(repaired.updatedAt instanceof Date) || isNaN(repaired.updatedAt.getTime())) {
      repaired.updatedAt = new Date();
    }

    // Fix invalid title
    if (!repaired.title || typeof repaired.title !== 'string') {
      repaired.title = 'Untitled Conversation';
    }

    // Fix invalid messages array
    if (!Array.isArray(repaired.messages)) {
      repaired.messages = [];
    } else {
      // Filter out invalid messages
      repaired.messages = repaired.messages.filter((message) => {
        return (
          message.id &&
          typeof message.id === 'string' &&
          message.content &&
          typeof message.content === 'string' &&
          message.role &&
          (message.role === 'user' || message.role === 'assistant') &&
          message.timestamp instanceof Date &&
          !isNaN(message.timestamp.getTime())
        );
      });
    }

    // Fix invalid boolean fields
    if (typeof repaired.isStreaming !== 'boolean') {
      repaired.isStreaming = false;
    }

    // Fix invalid arrays
    if (!Array.isArray(repaired.modelHistory)) {
      repaired.modelHistory = [];
    }

    if (!Array.isArray(repaired.compressionHistory)) {
      repaired.compressionHistory = [];
    }

    return repaired;
  }
}

/**
 * Get singleton instance of DataIntegrityService
 *
 * @param storage - ConversationStorage instance
 * @returns DataIntegrityService instance
 */
export function getDataIntegrityService(
  storage: ConversationStorage
): DataIntegrityService {
  return new DataIntegrityService(storage);
}

